import { VulnerabilityApiResponse, VulnerabilityWithStatus, VulnerabilityStatus, ApiError } from '@/types/api';

const API_BASE_URL = '/api/vulnerability'; // Use Next.js API proxy instead of direct backend call
const STORAGE_KEY = 'vulnerability_status';

export class VulnerabilityApiService {
    /**
     * Query vulnerabilities for a specific contract address
     */
    static async queryVulnerabilities(contractAddress: string): Promise<VulnerabilityWithStatus[]> {
        try {
            console.log(`Fetching vulnerabilities for contract: ${contractAddress}`);
            const response = await fetch(`${API_BASE_URL}/${contractAddress}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
            });

            console.log(`API Response status: ${response.status}`);

            if (!response.ok) {
                const errorText = await response.text();
                console.error('API Error response:', errorText);
                throw new Error(`API Error ${response.status}: ${errorText}`);
            }

            const responseText = await response.text();
            console.log('Raw API Response:', responseText);

            let apiData;
            try {
                apiData = JSON.parse(responseText);
            } catch (parseError) {
                console.error('JSON Parse Error:', parseError);
                throw new Error('Invalid JSON response from API');
            }

            console.log('Parsed API Response:', apiData);

            // If the API returns a single object instead of array, wrap it
            const vulnerabilities = Array.isArray(apiData) ? apiData : [apiData];

            // Load status data from localStorage
            const statusData = this.loadStatusFromStorage();

            // Combine API data with localStorage status and add pocSummary alias
            const vulnerabilitiesWithStatus: VulnerabilityWithStatus[] = vulnerabilities.map((vuln, index) => ({
                ...vuln,
                pocSummary: vuln.summary || vuln.pocSummary || 'No summary available', // Handle both field names
                status: statusData[vuln.id]?.status || 'new',
                serialNumber: index + 1
            }));

            console.log('Processed vulnerabilities:', vulnerabilitiesWithStatus);
            return vulnerabilitiesWithStatus;
        } catch (error) {
            console.error('Error querying vulnerabilities:', error);
            if (error instanceof Error) {
                throw error;
            }
            throw new Error('Failed to fetch vulnerability data');
        }
    }

    /**
     * Update vulnerability status and save to localStorage
     */
    static updateVulnerabilityStatus(
        vulnerabilityId: string,
        status: 'new' | 'acknowledged' | 'resolved'
    ): void {
        try {
            const statusData = this.loadStatusFromStorage();
            statusData[vulnerabilityId] = {
                status,
                updatedAt: new Date()
            };
            this.saveStatusToStorage(statusData);
        } catch (error) {
            console.error('Error updating vulnerability status:', error);
            throw new Error('Failed to update vulnerability status');
        }
    }

    /**
     * Get vulnerability status from localStorage
     */
    static getVulnerabilityStatus(vulnerabilityId: string): 'new' | 'acknowledged' | 'resolved' {
        const statusData = this.loadStatusFromStorage();
        return statusData[vulnerabilityId]?.status || 'new';
    }

    /**
     * Load status data from localStorage
     */
    private static loadStatusFromStorage(): VulnerabilityStatus {
        try {
            const storedData = localStorage.getItem(STORAGE_KEY);
            if (!storedData) return {};

            const parsed = JSON.parse(storedData);
            // Convert updatedAt strings back to Date objects
            Object.keys(parsed).forEach(key => {
                if (parsed[key].updatedAt) {
                    parsed[key].updatedAt = new Date(parsed[key].updatedAt);
                }
            });

            return parsed;
        } catch (error) {
            console.error('Error loading status from localStorage:', error);
            return {};
        }
    }

    /**
     * Save status data to localStorage
     */
    private static saveStatusToStorage(statusData: VulnerabilityStatus): void {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(statusData));
        } catch (error) {
            console.error('Error saving status to localStorage:', error);
            throw new Error('Failed to save status data');
        }
    }

    /**
     * Transform API response to match the existing UI VulnerabilityAlert interface
     */
    static transformToVulnerabilityAlert(vulnerabilities: VulnerabilityWithStatus[]) {
        return vulnerabilities.map(vuln => ({
            id: vuln.id,
            serialNumber: vuln.serialNumber,
            pocSummary: vuln.pocSummary,
            pocCodeLink: vuln.metadataURI,
            priorityScore: this.mapPriorityToScore(vuln.severity),
            contractHash: vuln.pocHash,
            detectedAt: new Date(vuln.blockTimestamp),
            status: vuln.status,
            category: this.mapPocTypeToCategory(vuln.pocType)
        }));
    }

    /**
     * Map API priority to UI priority score
     */
    private static mapPriorityToScore(priority: string): 1 | 2 | 3 | 4 | 5 {
        switch (priority.toLowerCase()) {
            case 'critical': return 1;
            case 'high': return 2;
            case 'medium': return 3;
            case 'low': return 4;
            default: return 5; // Info
        }
    }

    /**
     * Map API pocType to UI category
     */
    private static mapPocTypeToCategory(pocType: string): 'suspicious_transaction' | 'high_gas' | 'liquidity_exceeded' | 'pattern_match' {
        switch (pocType.toLowerCase()) {
            case 'reentrancy':
            case 'overflow':
            case 'underflow':
            case 'timestamp':
                return 'pattern_match';
            case 'high_gas':
            case 'gas_limit':
                return 'high_gas';
            case 'liquidity':
            case 'drain':
            case 'flashloan': // Handle FLASHLOAN attacks
                return 'liquidity_exceeded';
            case 'suspicious':
            case 'frontrun':
            case 'sandwich':
            default:
                return 'suspicious_transaction';
        }
    }

    /**
     * Clear all status data from localStorage
     */
    static clearAllStatus(): void {
        try {
            localStorage.removeItem(STORAGE_KEY);
        } catch (error) {
            console.error('Error clearing status data:', error);
        }
    }

    /**
     * Get all status data for debugging
     */
    static getAllStatus(): VulnerabilityStatus {
        return this.loadStatusFromStorage();
    }
}